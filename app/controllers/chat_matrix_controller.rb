# frozen_string_literal: true

class DiscourseChatMatrix::ChatMatrixController < ApplicationController
  requires_plugin DiscourseChatMatrix::PLUGIN_NAME

  layout false

  skip_before_action :verify_authenticity_token,
                     :redirect_to_login_if_required,
                     :preload_json,
                     :check_xhr

  before_action :ensure_chat_matrix_enabled

  LAST_TRANSACTION_REDIS_KEY = "matrix:last-transaction-id"
  LAST_TRANSACTION_EXPIRY = 1.day

  def well_known
    response.set_header("Access-Control-Allow-Origin", "*")
    response.set_header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
    response.set_header(
      "Access-Control-Allow-Headers",
      "X-Requested-With, Content-Type, Authorization",
    )

    render json: { "m.homeserver" => { "base_url" => SiteSetting.matrix_homeserver } }
  end

  def on_get_users
    puts "[on_get_users] user id = #{params[:id]}, body = #{request.body.read}"
    if user = User.from_matrix_id(params[:id])
      render json: {}
    else
      render status: 404, json: {}
    end
  end

  def on_get_room_alias
    puts "[on_get_room_alias] alias = #{params[:alias]}, body = #{request.body.read}"
    render json: {}
  end

  def on_transaction
    if !ActiveSupport::SecurityUtils.secure_compare(
         SiteSetting.matrix_hs_token,
         params[:access_token],
       )
      raise Discourse::InvalidAccess
    end

    return render body: nil, status: 400 if params[:id].blank?

    body =
      begin
        JSON.parse(request.body.read, symbolize_names: true)
      rescue StandardError
        nil
      end
    return render body: nil, status: 400 if body.blank?

    # Ensure transaction was not handled before
    puts "[on_transaction] transaction id = #{params[:id]}, body = #{body.to_json}"
    return render json: {} if Discourse.redis.get(LAST_TRANSACTION_REDIS_KEY) == params[:id]

    body[:events].each do |event|
      begin
        if event_id = event.dig(:event_id)
          # Skip this message if it was generated by an action from Discourse
          # to avoid echo
          next if DiscourseChatMatrix::MatrixEvents.ignored?(event_id)
        end

        DiscourseChatMatrix::MatrixEvents.call(event)
      rescue => e
        Rails.logger.error("Error handling Matrix error: #{e.message}, event: #{event}")
        puts "Error handling Matrix error: #{e.message}"
        puts "  event: #{event.to_json}"
        puts "  backtrace: #{e.backtrace.join("             \n")}"
        raise
      end
    end

    Discourse.redis.setex(LAST_TRANSACTION_REDIS_KEY, LAST_TRANSACTION_EXPIRY, params[:id])

    render json: {}
  end

  def on_health_check
    render json: {}
  end

  private

  def ensure_chat_matrix_enabled
    raise Discourse::NotFound if !SiteSetting.discourse_chat_matrix_enabled?
  end
end
